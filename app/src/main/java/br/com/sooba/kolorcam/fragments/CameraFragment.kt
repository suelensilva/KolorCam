package br.com.sooba.kolorcam.fragments

import android.Manifest
import android.app.Activity
import android.content.Context
import android.content.pm.PackageManager
import android.graphics.Matrix
import android.graphics.RectF
import android.graphics.SurfaceTexture
import android.hardware.camera2.*
import android.media.ImageReader
import android.os.Bundle
import android.os.Handler
import android.os.HandlerThread
import android.support.v4.app.ActivityCompat
import android.support.v4.content.ContextCompat
import android.util.Log
import android.util.Size
import android.view.LayoutInflater
import android.view.Surface
import android.view.TextureView.SurfaceTextureListener
import android.view.View
import android.view.ViewGroup
import br.com.sooba.kolorcam.R
import br.com.sooba.kolorcam.views.AutoFitTextureView
import java.util.*
import java.util.concurrent.Semaphore
import java.util.concurrent.TimeUnit

/**
 * Fragment to capture color using camera2 API
 */
class CameraFragment : android.support.v4.app.Fragment(), ActivityCompat.OnRequestPermissionsResultCallback {

    private val TAG = CameraFragment::class.simpleName
    private val REQUEST_CAMERA_PERMISSION = 20

    lateinit var mTextureView: AutoFitTextureView

    lateinit var mPreviewSize : Size

    /**
     * A {@link Semaphore} to prevent the app from exiting before closing the camera.
     */
    val mCameraOpenCloseLock = Semaphore(1)

    /**
     * ID of the current {@link CameraDevice}.
     */
    lateinit var mCameraId : String

    /**
     * A reference to the opened {@link CameraDevice}.
     */
    var mCameraDevice : CameraDevice? = null

    /**
     * An additional thread for running tasks that shouldn't block the UI.
     */
    lateinit var mBackgroundThread : HandlerThread

    /**
     * A {@link Handler} for running tasks in the background.
     */
    lateinit var mBackgroundHandler : Handler

    /**
     * {@link CaptureRequest.Builder} for the camera preview
     */
    lateinit var mPreviewRequestBuilder : CaptureRequest.Builder

    /**
     * A {@link CameraCaptureSession } for camera preview.
     */
    var mCaptureSession : CameraCaptureSession? = null

    /**
     * {@link CaptureRequest} generated by {@link #mPreviewRequestBuilder}
     */
    lateinit var mPreviewRequest : CaptureRequest

    /**
     * An {@link ImageReader} that handles still image capture.
     */
    lateinit var mImageReader : ImageReader

    /**
     * Whether the current camera device supports Flash or not.
     */
    var mFlashSupported : Boolean = false

    private val mSurfaceTextureListener : SurfaceTextureListener = object : SurfaceTextureListener {
        override fun onSurfaceTextureSizeChanged(texture: SurfaceTexture?, width: Int, height: Int) {
            configureTransform(width, height)
        }

        override fun onSurfaceTextureUpdated(texture: SurfaceTexture?) {
        }

        override fun onSurfaceTextureDestroyed(texture: SurfaceTexture?): Boolean {
            return true
        }

        override fun onSurfaceTextureAvailable(texture: SurfaceTexture?, width: Int, height: Int) {
            openCamera(width, height)
        }
    }

    /**
     * {@link CameraDevice.StateCallback} is called when {@link CameraDevice} changes its state.
     */
    private val mStateCallback : CameraDevice.StateCallback = object : CameraDevice.StateCallback() {
        override fun onOpened(cameraDevice: CameraDevice?) {
            mCameraOpenCloseLock.release()
            mCameraDevice = cameraDevice
            createCameraPreviewSession()
        }

        override fun onDisconnected(cameraDevice: CameraDevice?) {
            mCameraOpenCloseLock.release()
            cameraDevice?.close()
            mCameraDevice = null
        }

        override fun onError(cameraDevice: CameraDevice?, error: Int) {
            mCameraOpenCloseLock.release()
            mCameraDevice?.close()
            mCameraDevice = null
            activity!!.finish()
        }

    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
        return inflater.inflate(R.layout.camera_layout, container, false)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        mTextureView = view.findViewById<AutoFitTextureView>(R.id.texture_view)
    }

    override fun onResume() {
        super.onResume()

        startBackgroundThread()

        // When the screen is turned off and turned back on, the SurfaceTexture is already
        // available, and "onSurfaceTextureAvailable" will not be called. In that case, we can open
        // a camera and start preview from here (otherwise, we wait until the surface is ready in
        // the SurfaceTextureListener).
        if (mTextureView.isAvailable()) {
            openCamera(mTextureView.getWidth(), mTextureView.getHeight());
        } else {
            mTextureView.setSurfaceTextureListener(mSurfaceTextureListener);
        }
    }

    /**
     * Starts a background thread and its {@link Handler}.
     */
    fun startBackgroundThread() {
        mBackgroundThread = HandlerThread("CameraBackground")
        mBackgroundThread.start()
        mBackgroundHandler = Handler(mBackgroundThread.looper)
    }

    fun openCamera(width:Int, height:Int) {
        val activity = activity as Activity

        if(ContextCompat.checkSelfPermission(activity, Manifest.permission.CAMERA) !=
                PackageManager.PERMISSION_GRANTED) {
            requestCameraPermission()
            return
        }

        // TODO setUpCameraOutputs(width, height)
        configureTransform(width, height)

        val manager = activity.getSystemService(Context.CAMERA_SERVICE) as CameraManager

        try {
            if(!mCameraOpenCloseLock.tryAcquire(2500, TimeUnit.MILLISECONDS)) {
                throw RuntimeException("Time out waiting to lock camera opening")
            }
            manager.openCamera(mCameraId, mStateCallback, mBackgroundHandler)
        } catch (e : CameraAccessException) {
            Log.e(TAG, "CameraAccessException while trying to open camera", e)
        }
    }



    /**
     * Configures the necessary {@link android.graphics.Matrix} transformation to `mTextureView`.
     * This method should be called after the camera preview size is determined in
     * setUpCameraOutputs and also the size of `mTextureView` is fixed.
     *
     * @param viewWidth  The width of `mTextureView`
     * @param viewHeight The height of `mTextureView`
     */

    fun configureTransform(viewWidth:Int, viewHeight:Int) {
        val activity = activity ?: return

        val rotation : Int = activity.windowManager.defaultDisplay.rotation
        val matrix = Matrix()
        val viewRect = RectF(0f, 0f, viewWidth.toFloat(), viewHeight.toFloat())
        val bufferRect = RectF(0f, 0f, mPreviewSize.height.toFloat(), mPreviewSize.width.toFloat())
        val centerX = viewRect.centerX()
        val centerY = viewRect.centerY()

        if(Surface.ROTATION_90 == rotation || Surface.ROTATION_270 == rotation) {
            bufferRect.offset(centerX - bufferRect.centerX(), centerY - bufferRect.centerY())
            matrix.setRectToRect(viewRect, bufferRect, Matrix.ScaleToFit.FILL)

            val scale = Math.max(
                    viewHeight.toFloat() / mPreviewSize.height.toFloat(),
                    viewWidth.toFloat() / mPreviewSize.width.toFloat()
            )
            matrix.postScale(scale, scale, centerX, centerY)
            matrix.postRotate(90f * (rotation - 2), centerX, centerY)
        } else if (Surface.ROTATION_180 == rotation) {
            matrix.postRotate(180f, centerX, centerY)
        }

        mTextureView.setTransform(matrix)
    }

    fun requestCameraPermission() {
        val permissions = Array<String>(1,  init = {
            Manifest.permission.CAMERA
        })
        requestPermissions(permissions, REQUEST_CAMERA_PERMISSION)
    }

    /**
     * Creates a new {@link CameraCaptureSession} for camera preview.
     */
    fun createCameraPreviewSession() {
        try {
            val texture = mTextureView.surfaceTexture

            // We configure the size of default buffer to be the size of camera preview we want.
            texture.setDefaultBufferSize(mPreviewSize.width, mPreviewSize.height)

            // This is the output Surface we need to start preview.
            val surface = Surface(texture)

            // We set up a CaptureRequest.Builder with the output Surface.
            mPreviewRequestBuilder = mCameraDevice?.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW)!!
            mPreviewRequestBuilder.addTarget(surface)

            // Here, we create a CameraCaptureSession for camera preview.
            mCameraDevice!!.createCaptureSession(
                    Arrays.asList(surface, mImageReader.surface),
                    object : CameraCaptureSession.StateCallback() {
                        override fun onConfigureFailed(cameraCaptureSession: CameraCaptureSession?) {
                            TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
                        }

                        override fun onConfigured(cameraCaptureSession: CameraCaptureSession?) {
                            mCaptureSession = cameraCaptureSession

                            try {
                                // Auto focus should be continuous for camera preview.
                                mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE)

                                // Flash is automatically enabled when necessary.
                                setAutoFlash(mPreviewRequestBuilder)

                                // Finally, we start displaying the camera preview.
                                mPreviewRequest = mPreviewRequestBuilder.build();

                                // TODO
//                                mCaptureSession?.setRepeatingRequest(mPreviewRequest,
//                                        mCaptureCallback, mBackgroundHandler);
                            } catch (e: CameraAccessException) {
                                Log.e(TAG, "CameraAccessException while creating camera preview session", e)
                            }
                        }
                    },
                    null)
        } catch(e : CameraAccessException) {
            Log.e(TAG, "CameraAccessException while creating camera preview session", e)
        }
    }

    fun setAutoFlash(requestBuilder : CaptureRequest.Builder) {
        if(mFlashSupported) {
            requestBuilder.set(CaptureRequest.CONTROL_AE_MODE, CaptureRequest.CONTROL_AE_MODE_ON_AUTO_FLASH)
        }
    }


}